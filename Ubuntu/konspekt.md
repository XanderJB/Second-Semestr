  <h2>Командная строка</h2>
  <ol>
  <li>Исполняемые программы
  <li>Функции
  <li>Библиотечные вызовы
  <li>Специальные файлы
  <li>Форматы файлов
  <li>Игры
  <li>Пакеты макросов и соглашения
  <li>Команды администрирования системы
  <li>Процедуры ядра
  </ol>
  <h3>Редактирование и просмотр файлов<h3>
  <li>touch - создает файл если он не существует
  <li>cp - копирование файлов
  <li>mv - перемещение файлов
  <li>ln - создает ссылки на файлы
  <li>alias - создает алиас для команды
  <li>сd - переход в указанную папку
  <li>ls - содержимое директории
  <li>pwd отображает текущую директорию
  <li>readlink - путь  к файлу
  <li>rmdir - удаление папки
  <li>mkdir - создание папки
  <li>rm - удаление файлов <br>
  
  Права файлов
  <li>Чтение - позволяет увидеть содержимое файла, но не изменять его
  <li>Запись - позволяет изменить содержимое файла
 <li> Исполнение - выполнение указанного файла<br>
  
  Распространие прав файлов
  <li>Владелец - "автор" файла
  <li>Группа - группа пользователей в системе
  <li>Остальные - не входят в группу и не являются владельцами<br>
  
  <li>-rwx - admin
  <li>r -x - user
 <li> r-- - other<br>
  Пользователь root имеет доступ ко всемфайлам и может изменять и читать их<br>
  Минимальные права для директории - 5<br>
  ![image](https://user-images.githubusercontent.com/86486142/150746392-cad8f40f-4ba8-4ede-a0e2-283d77ade864.png)

Кто и когда
 <li> w - показывает, кто залогтнен и чем занят
 <li> who - КТО залогинен
 <li> wall - отправляет broadcast сообщение на все терминалы
 <li> useradd - утилита создание юзера
<li>  usermod - изменение аккаунта юзера
<li>  date - установка и изменение данных
<li>  cal - календарь
  
Потоки вывода ввода
 <li> STDIN(0) - стандартный ввод. Из него осуществялется чтение
  <li>STDOUT(1) - стандартный вывод. В него производится запись
<li>  STDERR(2) - стандартный поток ошибок
  
  Процесс - набор ресурсов задачи во время ее выполнения

память
файловые дескрипторы
контекст выполнения
обработчики сигналов
как минимум, один поток
Потоки имеют:
общую виртуальную память
каждый - свой виртуальный процессор

Структура памяти процесса:
Stack- адреса возврата из подпрограмм (аргументы функций)
mmap- разделяемая библиотека
Неиспользованная память
heap (Куча)
BSS- неициализированные глобальные и статистические переменные
data- инициализированные глобальные и статистические переменные
text- код программы


Трансляция адресов - первод виртуальной памяти в физическую


Виртуальная файловая система:

не имеет существующих файлов, существует только в оперативной памяти
содержит информацию о системы
в файлы можно писать значения, изменяя этим параметры системы
/proc/PID/maps - карта памяти процесса
/proc/PID/fd - открытые файловые дескрипторы
/proc/PID/environ - переменные окружения
/proc/PID/exe - симлинк на исполняемый файл
/proc/PID/cwd - симлинк на директорию, откуда запущен процесс
/proc/PID/status - состояние процесса в человекочитаемом виде

#Процессы<br>
Смерть процесса<br>
Процесс заканчивается системным вызовом exit() либо сигналом завершения<br>
сигнал процессу можно отправитьь командой kill<br>
после завершения дочерний процесс находится в сорстоянии зомби<br>
если родительский проусс завершился раньше дочернего - родительским становится другой поток родительского проу=цесса, либо init (pld=1)<br>
статус завершения итеративного процесса доступени в переменной окружения $? - она хранит код завершения последней команды<br>
  
ready - готов к выполнения. ждет распреденеия процессорного времени. <br>
  
  трассировщики - рограммы запускающие код пошагово. ои испрользуются для отладки <br>
  ![image](https://user-images.githubusercontent.com/86486142/152934913-3d2c4140-0124-439c-a08d-1c4153211969.png)
  
Первым доступ к системе получает дочерний роцесс
  за создание процесса отвечает фунция fork (англ. вилка)
для остановки процесса используется ctrl-z, чтобы продолжить - fg
  
Устройства<br>
Символьные устройства<br>
  устройство, реализующее последовательный поток данныхх, байт за байтом<br>
  имеют всего одну позицию - текущую<br>
  невозможно обратиться к случайным данным<br>
  примеры устрйств - клавиатура<br>
Блочные устройства<br>
  если устройство позволяет обращаться к данным слцчайным образом, то это блочное устройство<br>
  блочные устройства чувствительны к производительности<br>
  должны иметь возможность преддоставлять доступ по любому адресу в устройстве<br>
Сектор и блок<br>
  Сектор - это наименьший адресуемый элемент блочного устройства<br>
  стандартный размер - 512 байт<br>
  устройство не может работать с данными размером меньше сектораэ<br>
  для ядра и ПО минимально адресуемая единица данных для блочного устройства -блок<br>
  размер сектора равен размеру блока<br>
  размер блока не больше размера страницы памяти<br>
Очередть запросов<br>
  файловая система отправляет запросы к устройству в очередь<br>
  очередь содержит спиоск запросов на ввод\вывод и управляющую информацию<br>
  пока очередь не пуста, драйвер устройства извлекает запросы из очереди и отправляет на блочное устройство<br>
файловые системы<br>
  файловая система - способ отображения физ данных в файлы<br>
  задачи файлловой системы:<br>
  - отображение логического представления файлов на физическое<br>
  реализация пользовательского интерфейса для доступа к файлам<br>
  упорядочивание файлов<br>
  защита данных в случае аппаратного сбоя<br>
  реализация контроля доступа к данных<br>
иерархия файловой системы<br>
  в виндовс иерархия файловой системы начинается с имени логического диска<br>
  в линукс иерархия файловой системы представляет единое древо<br>
  / - корень файловой системы<br>
  /boot - файлы загрузчика и ядро<br>
  /etc - файлы конфигурации<br>
  /usr, /usr/local - программы пользователя<br>
  /bin, /usr/bin - исполняемые файлы<br>
  /home - домашние каталоги пользователей<br>
Абсолютные и относительные пути к файлу<br>
  имена файлов и директорий регистрозависимые файлы Тemp.txt и temp.txt <br>
Типы файлов <br>
  обычные txt<br>
  директории - d<br>
  ссылки (мягкие и жесткие) - d-l<br>
  сокеты - s<br>
прерывание и планировщие процессов<br>
  прерывание - событие требующие немедленной реации со стороны процессора<br>
  аппаратное прерывание - поступают в любой момент времени<br>
  программные - возникают синхронно при выполнении программы<br>
  маскируемые - процессор может игрорировать/немаскируемые - не может игнорировать<br>
  синхронные прерывания (исключения)<br>
планировщие процессов<br>
  планировщик - компонент ядра который определяет следующий процесс на выполнение<br>
  планировщик определяет из списка задач наиболее подходящую для выполнения<br>
  процессы, не готовые к выполнению блокируются используя ядро<br>
  многозадачные ОС позволяют выполнять одновременно несколько процессов используя вытесняющую многозадачность<br>
  решение о переключении на другой процесс принимает планировщик<br>
  кооперативную многозадачность<br>
  процесс сам решает когда прекратить выполлнение<br>
  клиент времени -период в течение которого процесс будет выполняться до того как завершит работу<br>
вытеснение процесса<br>
  линукс - ОС с вытеснением процесса<br>
  процесс А выполняется<br>
  процесс В "готов к исполнению"<br>
  ядро обнаруживает что процесс В более приоритетный чем процесс А<br>
  вызывается планировщик, вытесняет процесс А<br>
  процесс В ставится на выполнение<br>
  <h1>RabbitMQ, Docker</h1>
  <h2>RabbitMQ</h2>
  <p>RabbitMQ - это брокер сообщений с открытым исходным кодом. Кратко работу RabbitMQ можно описать следующим образом:</p>
  <p>Издатель отправляет сообщение определенному обменнику</p>
  <p>Обменник получив сообщение маршрутизирует его в одну или несколько очередей в соответствии с правилами привязки между ним и очередью</p>
  <p>Очередь хранит ссылку на это сообщение. Само сообщение хранится на оперативной памяти или на диске/p>
  <p>Как только потребитель готов получить сообщение на очереди, сервер создает копию сообщение по ссылке и отправляет</p>
  <p>Потребитель получает сообщение и отправляет брокеру подтверждение</p>
  <p>Брокер, получив подтверждение удаляет копию сообщения по очереди. Затем сообщение стирается из ОЗУ и диска</p>
  <h2>Docker</h2>
  <p>Docker(докер) - программное обеспечение с открытым исходным кодом, применяемое для разработки тестирования доставки и запуска веб-приложений в средах с поддержкой контейнеризации.Он нужен для того, чтобы более эффективно использовать систему ресурсов, быстро развертывать готовых программных продуктов, а также для их масштабирования и переноса в другие среды с гарантированным сохранением стабильной работы</p>
  <h2>Компоненты Docker-а</h2>
  <p>Docker-demon - сервер контейнеров, входящий в состав программных средств Docker. Демон управляет Docker-объектами</p>
  <p>Докер-клиент - интерфейс взаимодействия пользователя с докер-демоном</p>
  <p>докер-образ - файл, включающий зависимости, сведения, конфигурацию для дальнейшего развертывания и инициализации контейнера</p>
  <p>докер-файл - описание правил по сборке образа, в котором первая строка указывает на базовый образ. Последующие команды выполняют копирование файорв в установку программ для создания определенной среды для разработки.</p>
  <p>докер-контейнер - это легкий, автономный исполняемый пакет программного обеспечения, который включает в себя все необходимые для запуска приложения: код, среду выполнения, системные инструменты, библиотеки и настройки</p>
  <h2>Что происходит при запуске Docker-файла</h2>
  <p>Происходит запуск образа(Docker-image). Docker-engine проверяет существование образа. Если образ существует локально, докер использует его для нового контейнера. При его отсутствии выполняется скачивание с Docker-hub</p>
  <p>создание контейнера из образа</p>
  <p>разметка файловой системы и добавление слоя для записи</p>
  <p>создание сетевого интерфейса</p>
  <p>поиск и присвоение ip-адреса</p>
  <p>запуск указанного процесса</p>
  <p>захват ввода/вывода приложения</p>
  <h2>InfluxDB</h2>
  <p>Базы данных временных рядов работают определенным образом. Данные по прежнему хранятся в коллекциях, но эти коллекции имеют общий знаменатель: они объединены со временем. Это означает, что для каждой точки, которую вы можете сохранить. у вас связанная с ней временная метка/p>
  <h2>зачем нужны Базы данных временных рядов</h2>
  <p>База данных оптимизирована для быстрого приема данных. Такие системы используют индексацию данных, объединенных со временем. Как следствие скорость загрузки не уменьшается со временем и остается достаточно стабильной</p>
  ![image](https://user-images.githubusercontent.com/86486142/154933198-181d0559-2c6a-4f1a-a64d-da69a4851d16.png)

