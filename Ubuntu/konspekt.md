  <h2>Командная строка</h2>
  <ol>
  <li>Исполняемые программы
  <li>Функции
  <li>Библиотечные вызовы
  <li>Специальные файлы
  <li>Форматы файлов
  <li>Игры
  <li>Пакеты макросов и соглашения
  <li>Команды администрирования системы
  <li>Процедуры ядра
  </ol>
  <h3>Редактирование и просмотр файлов<h3>
  <li>touch - создает файл если он не существует
  <li>cp - копирование файлов
  <li>mv - перемещение файлов
  <li>ln - создает ссылки на файлы
  <li>alias - создает алиас для команды
  <li>сd - переход в указанную папку
  <li>ls - содержимое директории
  <li>pwd отображает текущую директорию
  <li>readlink - путь  к файлу
  <li>rmdir - удаление папки
  <li>mkdir - создание папки
  <li>rm - удаление файлов <br>
  
  Права файлов
  <li>Чтение - позволяет увидеть содержимое файла, но не изменять его
  <li>Запись - позволяет изменить содержимое файла
 <li> Исполнение - выполнение указанного файла<br>
  
  Распространие прав файлов
  <li>Владелец - "автор" файла
  <li>Группа - группа пользователей в системе
  <li>Остальные - не входят в группу и не являются владельцами<br>
  
  <li>-rwx - admin
  <li>r -x - user
 <li> r-- - other<br>
  Пользователь root имеет доступ ко всемфайлам и может изменять и читать их<br>
  Минимальные права для директории - 5<br>
  ![image](https://user-images.githubusercontent.com/86486142/150746392-cad8f40f-4ba8-4ede-a0e2-283d77ade864.png)

Кто и когда
 <li> w - показывает, кто залогтнен и чем занят
 <li> who - КТО залогинен
 <li> wall - отправляет broadcast сообщение на все терминалы
 <li> useradd - утилита создание юзера
<li>  usermod - изменение аккаунта юзера
<li>  date - установка и изменение данных
<li>  cal - календарь
  
Потоки вывода ввода
 <li> STDIN(0) - стандартный ввод. Из него осуществялется чтение
  <li>STDOUT(1) - стандартный вывод. В него производится запись
<li>  STDERR(2) - стандартный поток ошибок
  
  Процесс - набор ресурсов задачи во время ее выполнения

память
файловые дескрипторы
контекст выполнения
обработчики сигналов
как минимум, один поток
Потоки имеют:
общую виртуальную память
каждый - свой виртуальный процессор

Структура памяти процесса:
Stack- адреса возврата из подпрограмм (аргументы функций)
mmap- разделяемая библиотека
Неиспользованная память
heap (Куча)
BSS- неициализированные глобальные и статистические переменные
data- инициализированные глобальные и статистические переменные
text- код программы


Трансляция адресов - первод виртуальной памяти в физическую


Виртуальная файловая система:

не имеет существующих файлов, существует только в оперативной памяти
содержит информацию о системы
в файлы можно писать значения, изменяя этим параметры системы
/proc/PID/maps - карта памяти процесса
/proc/PID/fd - открытые файловые дескрипторы
/proc/PID/environ - переменные окружения
/proc/PID/exe - симлинк на исполняемый файл
/proc/PID/cwd - симлинк на директорию, откуда запущен процесс
/proc/PID/status - состояние процесса в человекочитаемом виде

#Процессы<br>
Смерть процесса<br>
Процесс заканчивается системным вызовом exit() либо сигналом завершения<br>
сигнал процессу можно отправитьь командой kill<br>
после завершения дочерний процесс находится в сорстоянии зомби<br>
если родительский проусс завершился раньше дочернего - родительским становится другой поток родительского проу=цесса, либо init (pld=1)<br>
статус завершения итеративного процесса доступени в переменной окружения $? - она хранит код завершения последней команды<br>
  
ready - готов к выполнения. ждет распреденеия процессорного времени. <br>
  
  трассировщики - рограммы запускающие код пошагово. ои испрользуются для отладки <br>
  ![image](https://user-images.githubusercontent.com/86486142/152934913-3d2c4140-0124-439c-a08d-1c4153211969.png)
  
Первым доступ к системе получает дочерний роцесс
  за создание процесса отвечает фунция fork (англ. вилка)
для остановки процесса используется ctrl-z, чтобы продолжить - fg
  
Устройства
Символьные устройства
  устройство, реализующее последовательный поток данныхх, байт за байтом
  имеют всего одну позицию - текущую
  невозможно обратиться к случайным данным
  примеры устрйств - клавиатура
Блочные устройства
  если устройство позволяет обращаться к данным слцчайным образом, то это блочное устройство
  блочные устройства чувствительны к производительности
  должны иметь возможность преддоставлять доступ по любому адресу в устройстве
Сектор и блок
  Сектор - это наименьший адресуемый элемент блочного устройства
  стандартный размер - 512 байт
  устройство не может работать с данными размером меньше сектораэ
  для ядра и ПО минимально адресуемая единица данных для блочного устройства -блок
  размер сектора равен размеру блока
  размер блока не больше размера страницы памяти
Очередть запросов
  файловая система отправляет запросы к устройству в очередь
  очередь содержит спиоск запросов на ввод\вывод и управляющую информацию
  пока очередь не пуста, драйвер устройства извлекает запросы из очереди и отправляет на блочное устройство
файловые системы
  файловая система - способ отображения физ данных в файлы
  задачи файлловой системы:
  - отображение логического представления файлов на физическое
  реализация пользовательского интерфейса для доступа к файлам
  упорядочивание файлов
  защита данных в случае аппаратного сбоя
  реализация контроля доступа к данных
иерархия файловой системы
  в виндовс иерархия файловой системы начинается с имени логического диска
  в линукс иерархия файловой системы представляет единое древо
  / - корень файловой системы
  /boot - файлы загрузчика и ядро
  /etc - файлы конфигурации
  /usr, /usr/local - программы пользователя
  /bin, /usr/bin - исполняемые файлы
  /home - домашние каталоги пользователей
Абсолютные и относительные пути к файлу
  имена файлов и директорий регистрозависимые файлы Тemp.txt и temp.txt 
Типы файлов 
  обычные txt
  директории - d
  ссылки (мягкие и жесткие) - d-l
  сокеты - s
прерывание и планировщие процессов
  прерывание - событие требующие немедленной реации со стороны процессора
  аппаратное прерывание - поступают в любой момент времени
  программные - возникают синхронно при выполнении программы
  маскируемые - процессор может игрорировать/немаскируемые - не может игнорировать
  синхронные прерывания (исключения)
планировщие процессов
  планировщик - компонент ядра который определяет следующий процесс на выполнение
  планировщик определяет из списка задач наиболее подходящую для выполнения
  процессы, не готовые к выполнению блокируются используя ядро
  многозадачные ОС позволяют выполнять одновременно несколько процессов используя вытесняющую многозадачность
  решение о переключении на другой процесс принимает планировщик
  кооперативную многозадачность
  процесс сам решает когда прекратить выполлнение
  клиент времени -период в течение которого процесс будет выполняться до того как завершит работу
вытеснение процесса
  линукс - ОС с вытеснением процесса
  процесс А выполняется
  процесс В "готов к исполнению"
  ядро обнаруживает что процесс В более приоритетный чем процесс А
  вызывается планировщик, вытесняет процесс А
  процесс В ставится на выполнение
